import pandas as pd
import numpy as np
from vr2p.gimbl.transform import add_ranged_timestamp_values

def parse_linear_2ac(df,vr):
    # get environment info:
    vr.environment = parse_environment_info(df)
    # get trial info
    vr.trial = parse_trial_info(df)
    # get period info.
    vr.period = parse_period_info(df)
    # get interim info.
    vr.interim = parse_interim_info(vr.trial)
    # parse settings info
    vr.settings = parse_settings_info(df)
    # add settings info to trial info.
    vr.trial = pd.merge_asof(vr.trial.rename(columns={'time_start':'time'}), vr.settings[['time','is_guided','allow_multiple_responses','freeze_on_incorrect']],on='time')
    vr.trial = vr.trial.rename(columns={'time':'time_start'})
    # get position info reward. (before trial info since reward is given between trials.)
    if not vr.reward.empty:
        vr.reward = pd.merge_asof(vr.reward, vr.path.time, on='time')
    # add trial info to path position info.
    vr.path.time = add_ranged_timestamp_values(vr.path.time, vr.trial,['trial_number'])
    vr.path.frame = add_ranged_timestamp_values(vr.path.frame, vr.trial,['trial_number'])
    # add period info to path position info.
    vr.path.time = add_ranged_timestamp_values(vr.path.time, vr.period,['period','period_number'])
    vr.path.frame = add_ranged_timestamp_values(vr.path.frame, vr.period,['period','period_number'])
    # add interim info to path position info.
    vr.path.time = add_ranged_timestamp_values(vr.path.time, vr.interim,['interim_number'])
    vr.path.frame = add_ranged_timestamp_values(vr.path.frame, vr.interim,['interim_number'])
    # add position and trial info to lick and reward.
    if not vr.lick.empty:
        vr.lick = pd.merge_asof(vr.lick, vr.path.time, on='time')
    if not vr.reward.empty:
        vr.reward = pd.merge_asof(vr.reward, vr.trial[['time_start','trial_number']].rename(columns={'time_start':'time'}), on='time')
    return vr

def parse_trial_info(df):
    """Generates new trial info dataframe from gimbl log containing

    Args:
        df ([DataFrame]): raw dataframe generated by vr2p.gimbl.parse parse_gimbl_log

    Returns:
        [DataFrame]: trial info
                index: 
                    "index" 
                columns: 
                    "trial_number"      -- (int) trial number,
                    "time_start"        -- (timedelta64) start time of trial,
                    "time_end"          -- (timedelta64) end time of trial,
                    "set"               -- (category) used cue set,
                    "reward_id"         -- (int) id of cue that was rewarding (starts at 1),
                    "status"            -- (category) result of trial (CORRECT,INCORRECT,NO_RESPONSE)

    """
    # get trial info.
    trial_info = df.loc[df['msg']=='StartTrial',['time','data.trialNum','data.rewardSet','data.rewardingCueId']]
    # rename columns.
    trial_info = trial_info.rename(columns={'data.rewardSet':'set','data.rewardingCueId':'reward_id','data.trialNum':'trial_number','time':'time_start'})
    # adjust variable type.
    trial_info = trial_info.astype({'trial_number':'int','set':'category','reward_id':'uint'})
    # reset index.
    trial_info = trial_info.reset_index(drop=True)
    # get end info.
    end_info = df.loc[df['msg']=='EndTrial',['time','data.trialNum','data.status']]
    end_info = end_info.rename(columns={'data.trialNum':'trial_number','data.status':'status','time':'time_end'})
    end_info = end_info.reset_index(drop=True)
    end_info = end_info.loc[end_info['trial_number']>=0]
    # merge.
    trial_info = pd.merge(trial_info, end_info, on="trial_number",how='outer')
    # deal with incomplete (NaN) trials.
    trial_info['time_end'] = trial_info['time_end'].fillna(pd.Timedelta.max)
    trial_info['status'] = trial_info['status'].fillna('INCOMPLETE').astype('category')
    # Replace 'in_progress' with incomplete.
    trial_info['status'] = trial_info['status'].replace('IN_PROGRESS','INCOMPLETE')
    # set categories (in case of missing values)
    trial_info['status'] = trial_info['status'].cat.set_categories(['CORRECT','INCORRECT','NO_RESPONSE','INCOMPLETE'])
    # reorder.
    trial_info = trial_info[['trial_number','time_start','time_end','set','reward_id','status']]
    # !! SOmetimes last trial is counted twice. (fix this bug)!!
    trial_info =  trial_info.drop_duplicates(subset='trial_number')
    return trial_info

def parse_period_info(df):
    """Parses information on the periods present in the session (DARK/TASK)

    Args:
        df ([DataFrame]): raw dataframe generated by vr2p.gimbl.parse parse_gimbl_log

    Returns:
        [DataFrame]: period infos
                index: 
                    "index" 
                columns: 
                    "period"       -- (category) period type (DARK/TASK),
                    "period_number"       -- (int) cumulative count of period type,
                    "time_start"        -- (timedelta64) start time of trial,
                    "time_end"          -- (timedelta64) end time of trial,
    """
    # get period info.
    period_info = df.loc[df['msg']=='StartPeriod',['time','data.type','data.cueSet','data.duration','data.isGuided']].reset_index(drop=True).reset_index()
    period_info = period_info.rename(columns={'time':'time_start','data.type':'period','data.cueSet':'set','data.duration':'duration','data.isGuided':'is_guided'})
    # set types.
    period_info['period'] = period_info['period'].str.upper().astype('category').cat.set_categories(['DARK','TASK'])
    period_info['set'] = period_info['set'].astype('category')
    period_info['duration'] =period_info['duration'].astype('float')
    period_info['duration'] /=1000
    period_info['duration'] = pd.to_timedelta(period_info['duration'], unit='min')
    end_time = df.loc[df['msg']=='EndPeriod',['time']].reset_index(drop=True).reset_index().rename(columns ={'time':'time_end'})
    period_info = pd.merge(period_info, end_time, how="outer").drop(columns='index')
    # fill missing end periods (premature stop) with last time stamp on record.
    period_info['time_end'].fillna(df.iloc[-1].time, inplace=True)
    # add period count.
    period_info['period_number'] = period_info.groupby('period').cumcount()+1
    # order.
    period_info = period_info[['period_number','time_start','time_end','duration','period','set','is_guided']]
    return period_info

def parse_interim_info(trial_info):
    """Parses info on interim period between trials

    Args:
        trial_info (DataFrame): As created by parse_trial_info
    """
    # start times.
    interim_info = pd.DataFrame()
    interim_info['interim_number'] = trial_info['trial_number']
    interim_info['time_start'] = trial_info['time_end'].values + pd.to_timedelta('1ms')
    interim_info.drop(interim_info.tail(1).index,inplace=True)
    # end times.
    end_times = pd.DataFrame()
    end_times['interim_number'] = trial_info['trial_number']-1
    end_times['time_end'] = trial_info['time_start'].values - pd.to_timedelta('1ms')
    end_times.drop(interim_info.head(1).index,inplace=True)
    # merge.
    interim_info = pd.merge(interim_info, end_times, on="interim_number",how='outer')
    return interim_info

def parse_settings_info(df):
    """Parse settings info from raw log dataframe

    Args:
        df ([DataFrame]): raw dataframe generated by vr2p.gimbl.parse parse_gimbl_log

    Returns:
        [DataFrame]: parsed settings info.
    """
    # add possible missing settings (old versions.)
    setting_fields = ['time','data.isGuided','data.allowMultipleResponses', 'data.useLeftRightIndicators',
                    'data.freezeOnIncorrect', 'data.playFreezeSound',
                    'data.freezeIncorrectDuration', 'data.teleportDarkDuration', 'data.incorrectDarkDuration',
                    'data.teleportFadeDuration', 'data.lockOnTeleport', 'data.poissonLambda','data.maxRepeats']
    for field in setting_fields:
        if field not in df:
            df[field] = np.nan

    # get settings info.
    settings_info = df.loc[df['msg']=='Settings',setting_fields].dropna(axis=1)

    # rename columns.
    settings_info = settings_info.rename(columns={'data.isGuided':'is_guided',
    'data.allowMultipleResponses':'allow_multiple_responses',
    'data.useLeftRightIndicators': 'left_right_indicators',
    'data.freezeOnIncorrect':'freeze_on_incorrect',
    'data.playFreezeSound':'play_freeze_sound',
    'data.freezeIncorrectDuration': 'freeze_incorrect_duration',
    'data.teleportDarkDuration':'teleport_dark_duration',
    'data.incorrectDarkDuration':'incorrect_dark_duration',
    'data.teleportFadeDuration':'teleport_fade_duration',
    'data.lockOnTeleport':'lock_on_teleport',
    'data.poissonLambda':'poisson_lambda',
    'data.maxRepeats':'max_repeats'})
    #reset index.
    settings_info = settings_info.reset_index(drop=True)
    return settings_info

def parse_environment_info(df):
    # get period info.
    environment_info = df.loc[df['msg']=='Environment',['time','data.name','data.indicatorPosition','data.indicatorSize',
                                                'data.rewPositions','data.rewSizes','data.stopPosition',
                                                'data.grayZonePosition','data.grayZoneSize']].reset_index(drop=True).reset_index()
    environment_info = environment_info.rename(columns={'data.name':'name',
                                            'data.indicatorPosition': 'indicator_position',
                                            'data.indicatorSize':'indicator_size',
                                            'data.rewPositions':'reward_positions',
                                            'data.rewSizes':'reward_sizes',
                                            'data.stopPosition':'stop_position',
                                            'data.grayZonePosition':'gray_zone_position',
                                            'data.grayZoneSize':'gray_zone_size'})

    # adjust scale.
    fields = ['indicator_position','indicator_size','stop_position','gray_zone_position','gray_zone_size']
    for field in fields:
        environment_info[field] = environment_info[field]/100
    num_cues = len(environment_info['reward_positions'][0])
    labels = [f'reward_position_{i+1}'for i in range(num_cues)]
    environment_info[labels] = pd.DataFrame(environment_info['reward_positions'].tolist(), index= environment_info.index)
    environment_info[labels] = environment_info[labels]/100
    environment_info['reward_positions'] = environment_info[labels].values.tolist()
    labels = [f'reward_size_{i+1}'for i in range(num_cues)]
    environment_info[labels] = pd.DataFrame(environment_info['reward_sizes'].tolist(), index= environment_info.index)
    environment_info[labels] = environment_info[labels]/100
    environment_info['reward_sizes'] = environment_info[labels].values.tolist()
    return environment_info